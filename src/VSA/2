40,41c40,41
< let recoverVariables (env: AbsEnv) =
<   let doPrint (KeyValue (k, v)) =
---
> let recoverVariables acc1 (env: AbsEnv) =
>   let doPrint acc2 (KeyValue (k, v)) =
44c44,45
<       if mem = MemRgn.Global then printfn "%A" k
---
>       //printfn "%A: %s" k (v.ToString ())
>       if mem = MemRgn.Global then printfn "%A" k;acc2
47,48c48,49
<         if offset = 0L || offset = -8L then ()
<         else printfn "%A" newALoc
---
>         if offset = 0L || offset = -8L then acc2
>         else List.append [newALoc] acc2
61,62c62,63
<     | _ -> acc2//"%A: %s" k (v.ToString ());acc2
<   env |> Seq.iter doPrint
---
>     | _ -> acc2//printfn "%A: %s" k (v.ToString ());acc2
>   env |> Seq.fold doPrint acc1
1113a1115
>   //printfn "%A %A %A" ctxt.LoopFlag ctxt.LoopCurId ctxt.LoopStack
1219a1222,1230
> let removeSucc ctxt edge =
>   let parId = ctxt.ParBBLId
>   match ctxt.LoopTempId = parId with
>   | true ->
>     let lctxt = ctxt.LoopCtxt.[parId]
>     if ctxt.LoopFlag > 2 && lctxt.BackEdge <> edge then true
>     else false
>   | _ -> false
> 
1221a1233,1235
>   let id = ctxt.LoopTempId
>   let lctxt = LoopContext.visit ctxt.LoopCtxt.[id]
>   let ctxt = Context.addLoopCtxt [lctxt] ctxt
1237c1251
<       | true -> FallThroughEdge
---
>       | true -> RetEdge
1244c1258
<       | true -> FallThroughEdge
---
>       | true -> RetEdge
1275a1290
> //  elif removeSucc ctxt edge then ctxt, CallEdge
1286,1287c1301,1302
<       if isGoto then // TODO : Consider other cases
<         let flag, id, ctxt = Context.popLoopStack ctxt
---
>       if isGoto then
>         let flag, id, ctxt = Context.gotoLoopStack id ctxt
1310c1325
<       if ctxt.JmpFlag <> edge then ctxt, FallThroughEdge
---
>       if ctxt.JmpFlag <> edge then ctxt, RetEdge
1343c1358
<       if edge <> FallThroughEdge then handleVertex paramCtxt
---
>       if edge <> CallEdge || edge <> RetEdge then handleVertex paramCtxt
1355a1371,1377
>     elif (oldCtxt.LoopFlag <= 0 || oldCtxt.LoopCtxt.[lId].Visit = true) &&
>          v.IsVisited then
>       let edge = ssacfg.FindEdge pred v
>       if edge = FallThroughEdge || edge = CallEdge then
>         let oldCtxt = removeRetAddr f oldCtxt
>         Context.addRetEnv oldCtxt.Env oldCtxt
>       else Context.addRetEnv oldCtxt.Env oldCtxt
1356a1379,1381
>       v.Visit()
>       let id = v.GetID ()
>       let oldCtxt = Context.setCurBBLId id oldCtxt
1358,1364c1383,1390
<       if (oldCtxt.LoopFlag <= 0 || oldCtxt.LoopCtxt.[lId].Visit = true) &&
<          edge <> CallEdge && edge <> RetEdge && v.IsVisited then
<         let edge = ssacfg.FindEdge pred v
<         if edge = FallThroughEdge then
<           let oldCtxt = removeRetAddr f oldCtxt
<           Context.addRetEnv oldCtxt.Env oldCtxt
<         else Context.addRetEnv oldCtxt.Env oldCtxt
---
>       let oldCtxt, edge = Context.addEdge oldCtxt.ParBBLId edge oldCtxt
>                           |> Context.addBBL id v |> pathSens edge
>       let oldCtxt, edge = loopHandler v oldCtxt edge
>       let oldCtxt, edge = joinCond oldCtxt edge
>       if edge = RetEdge then Context.addRetEnv oldCtxt.Env oldCtxt
>       elif edge = CallEdge then
>         let oldCtxt = removeRetAddr f oldCtxt
>         Context.addRetEnv oldCtxt.Env oldCtxt
1366,1394c1392,1397
<         v.Visit()
<         let id = v.GetID ()
<         let oldCtxt = Context.setCurBBLId id oldCtxt
<         let oldCtxt, edge = Context.addEdge oldCtxt.ParBBLId edge oldCtxt
<                             |> Context.addBBL id v |> pathSens edge
<         let oldCtxt, edge = loopHandler v oldCtxt edge
<         let oldCtxt, edge = joinCond oldCtxt edge
<         if edge = FallThroughEdge then
<           let oldCtxt = removeRetAddr f oldCtxt
<           Context.addRetEnv oldCtxt.Env oldCtxt
<         elif edge = RetEdge then
<           let head, funCtxt = FunContext.getRetBBL oldCtxt.FunCtxt
<           let oldCtxt = Context.setFunCtxt funCtxt oldCtxt
<           if succ = head then
<             let oldCtxt = mainLoop edge oldCtxt
<             if List.isEmpty v.Succs then
<               Context.addRetEnv oldCtxt.Env oldCtxt
<             else v.Succs |> List.fold handleSucc oldCtxt
<           else Context.addRetEnv oldCtxt.Env oldCtxt
<         else
<           let oldCtxt =
<             if edge = CallEdge then
<               let lastStmt = pred.VData.GetStmts () |> List.rev |> List.head
<               let oldCtxt = getRetDest pred v oldCtxt
<               interProceduralVSA oldCtxt f funcs lastStmt cs
<               |> removeRetAddr f |> mainLoop edge
<             else mainLoop edge oldCtxt
<           if List.isEmpty v.Succs then Context.addRetEnv oldCtxt.Env oldCtxt
<           else v.Succs |> List.fold handleSucc oldCtxt
---
>         let oldCtxt =
>           if edge = FallThroughEdge then
>             removeRetAddr f oldCtxt |> mainLoop edge
>           else mainLoop edge oldCtxt
>         if List.isEmpty v.Succs then Context.addRetEnv oldCtxt.Env oldCtxt
>         else v.Succs |> List.fold handleSucc oldCtxt
1400,1407c1403,1411
<   let ssacfg = f.SSACFG
<   // loop Analysis
<   let root = ssacfg.GetRoot ()
<   // Value Set Analysis
<   let ctxt = Context.init (initializeAbsEnv f) (root.GetID ())
<             |> Context.addLoopCtxt cycleList
<   let ret = intraProceduralVSA ctxt f funcs_ []
<   recoverVariables ret.RetEnv
---
>   let main acc1 (f:Function) =
>     let ssacfg = f.SSACFG
>     let root = ssacfg.GetRoot ()
>     let ctxt = Context.init (initializeAbsEnv f) (root.GetID ())
>                |> Context.addLoopCtxt cycleList
>     let ret = intraProceduralVSA ctxt f funcs_ []
>     recoverVariables acc1 ret.RetEnv
>   let re = fList |> List.fold (fun acc elem -> main acc elem) []
>   re |> List.iter (fun elem -> printfn "%A" elem )
