<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>B2R2.NameMangling</name></assembly>
<members>
<member name="T:B2R2.NameMangling.ManglingScheme.UnknownMangler">
<summary>
 Unknown mangling scheme.
</summary>
</member>
<member name="T:B2R2.NameMangling.ManglingScheme.ItaniumMangler">
<summary>
 Itanium CXX name mangling scheme used by GCC 3.x and higher, Clang 1.x and
 higher.
</summary>
</member>
<member name="T:B2R2.NameMangling.ManglingScheme.MSMangler">
<summary>
 Microsoft Visual C++ name mangling.
</summary>
</member>
<member name="T:B2R2.NameMangling.ManglingScheme">
<summary>
 Name mangling schemes.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSUserState">
<summary>
 Userstate to handle name and type substitutions.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ConcatT">
<summary>
 Concatinate Type of MSExpr list.
 Concatinates the demangled string of each MSExpr in the list.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.IgnoredType">
<summary>
 Ingored type for temlates.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ThunkF">
<summary>
 Thunk Function type of calling Type * Name Component * Type Component
 * Return Type
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ArrayType">
<summary>
 Array type (not pointer to array) of modified data type * dimension.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ArrayPtr">
<summary>
 Pointer to an array of pointerStrTs * dimensions * Array data type.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ValueT">
<summary>
 Value of name * type.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ModifiedType">
<summary>
 Modified type of type * modifiers.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ConstructedTemplate">
<summary>
 Constructor comming inside templates.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.MangledSymbolPtr">
<summary>
 Mangled symbol pointer that comes only as template parameter.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.NestedFunc">
<summary>
 Function nested in another function.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.RTTI0">
<summary>
 RTTI0 code of any type.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.Destructor">
<summary>
 A destructor of Name.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.Constructor">
<summary>
 A constructor of Name.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.Template">
<summary>
 A template of FullName * Arguement types.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.FunctionT">
<summary>
 A function of scope * modifiers * calling convention * Name
 * ReturnType * ParameterTypes * ReturnType modifiers (if any).
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.FuncPointer">
<summary>
 For functions as arguements with PointerStrs, calling convention,
 return type , carry string, and Parameter types.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.EnumType">
<summary>
 EnumType of the Enum data type * name.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ComplexT">
<summary>
 Whole information of a complex type of complaexTypeKind * TypeBody.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.PointerT">
<summary>
 A pointer type of PointerStrType * PointedType.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.PointerStrT">
<summary>
 PointerStrT of PointerType * (prefixes * cvModifier) * cvTypeMSExpr.
 The cvTypeMSExpr differentiates between normalPointers, __basedPointers,
 memberPointers, or __based member pointers.
 Has all the information about the pointer symbol including prefixes.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.ExtendedBuiltInType">
<summary>
 An MSExpr form for an underscored builtInType represented by an underscore
 first then a single letter.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.SimpleBuiltInType">
<summary>
 An MSExpr form for a normal builtInType represented by a single letter.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.FullName">
<summary>
 A nested name without type information.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr.Name">
<summary>
 A name without type information.
</summary>
</member>
<member name="T:B2R2.NameMangling.MSExpr">
<summary>
 AST for microsoft mangled expressions.
</summary>
</member>
<member name="T:B2R2.NameMangling.ArrayLength">
<summary>
 Indicates the dimension(length) of the array.
</summary>
</member>
<member name="T:B2R2.NameMangling.InterpHelperString">
<summary>
 Not used while parsing. Only used during interpretation when a function
 returns a function pointer to accomodate the weird syntax.
</summary>
</member>
<member name="T:B2R2.NameMangling.UnderscoredBuiltInType">
<summary>
 Built in types that are represented by an underscore (_), then a letter.
</summary>
</member>
<member name="T:B2R2.NameMangling.NormalBuiltInType">
<summary>
 Built in types represented by a single letter.
</summary>
</member>
<member name="T:B2R2.NameMangling.PointerTypeIndicator">
<summary>
 Indicates the type of the pointer.
</summary>
</member>
<member name="T:B2R2.NameMangling.CVModifier">
<summary>
 Indicates CV class modifier.
</summary>
</member>
<member name="T:B2R2.NameMangling.ModifierPrefix">
<summary>
 Indicates modifier prefixes for a CV Modifier.
</summary>
</member>
<member name="T:B2R2.NameMangling.CallScope">
<summary>
 Indicates the calling scope(access level).
</summary>
</member>
<member name="T:B2R2.NameMangling.CallConvention">
<summary>
 Indicates the calling convention.
</summary>
</member>
<member name="T:B2R2.NameMangling.ComplexTypeKind">
<summary>
 Indicates the type of the complex type.
</summary>
</member>
<member name="T:B2R2.NameMangling.EnumTypeKind">
<summary>
 Indicates the data type in the Enum Type.
</summary>
</member>
<member name="M:B2R2.NameMangling.MSParser.Run(System.String)">
<summary>
 Runs parser from a string.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ParameterRef">
<summary>
 Function paramater references.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ExpressionArgPack">
<summary>
 Expression for expanding argument pack.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.DotPointerExpr">
<summary>
 expr.*expr .
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.DotExpr">
<summary>
 expr.name .
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ConversionMore">
<summary>
 Conversion with more than one argument.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ConversionOne">
<summary>
 Conversion with one argument.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ScopedLambda">
<summary>
 Lambda xpression together with scope encoding.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.MemberPAsArgument">
<summary>
 Member pointers as independent arguments.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.CastOperator">
<summary>
 Cast and Vendor extended operators.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.MemberPointer">
<summary>
 Pointer to member function.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ReferenceTemporary">
<summary>
 Lifetime - Extended temporary.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.TransactionSafeFunction">
<summary>
 Transaction entry point for function declared transaction safe.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.VirtualThunkRet">
<summary>
 Virtual override thunks with covariant return.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.VirtualThunk">
<summary>
 Virtual function override thunks with call offset and base encoding.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.CallOffset">
<summary>
 Adjustment offset for virtual override thunks.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Functionarg">
<summary>
 Created for special case of CV qualifiers, first element is qualifier.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ArrayPointer">
<summary>
 Array arguments encoded with their size and type.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Restrict">
<summary>
 Restrict qualifer which is applied to pointer arguments. There can be
 const or volatile between pointer sign (*) and restrict qualifier.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.FunctionBegin">
<summary>
 Beginning of function pointer in mangling which is
 consisted of qualifiers and pointers. First list expression is
 qualifiers with pointers, such as const*, second expression is successive
 pointers (For example, *****).
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ReferenceArg">
<summary>
 CV qualifiers followed by reference qualifier in code.
 For example, const&amp;.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.RefArg">
<summary>
 Arguments with reference qualifiers.
 Second expression can be PointerArg too.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.PointerArg">
<summary>
 Arguments with pointer (string part, single pointer) and CV qualifiers.
 The string part is a single character string &quot;P&quot;.
 It is defined like this for making substitution easier.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.CVR">
<summary>
 CV qualifiers followed by reference in mangled form. This form is only
 used in nested names.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Reference">
<summary>
 Reference qualifiers, &amp; and &amp;&amp;.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ConstVolatile">
<summary>
 CV qualifiers followed by pointers. For example, const*.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.CVqualifier">
<summary>
 Constant and volatile qualifiers. This includes, const, volatile and
 const volatile together.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.BinaryExpr">
<summary>
 Binary expression is composed operator and two arguments.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.UnaryExpr">
<summary>
 Unary expression is composed of operator and single argument.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.FunctionPointer">
<summary>
 Function Pointer is composed of pointers and optional qualifiers, return
 and arguments.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.ConsOrDes">
<summary>
 Constructors and Destructors.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Function">
<summary>
 Function with optional scope encoding(s), name
 (name, template, nestedname and etc.), return and arguments.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Template">
<summary>
 Template composed of name and arguments.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.NestedName">
<summary>
 Nested name composed of optional qualifiers and
 list of names, Sx abbreviation, templates and operator names.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Arguments">
<summary>
 Many arguments.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.RTTIandVirtualTable">
<summary>
 Virtual Table and RTTI values.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.SingleArg">
<summary>
 Function, template, operator or expression argument.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Pointer">
<summary>
 Many pointers encoded by consecutive &apos;P&apos;s.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.SingleP">
<summary>
 Single pointer encoded by character &apos;P&apos;.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Literal">
<summary>
 Literals encoded with their type and value.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.BuiltinType">
<summary>
 Builtin types.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Vendor">
<summary>
 Builtin extended types by vendors.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Sxoperator">
<summary>
 Sx abbreviation and operator.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Sxname">
<summary>
 Sx abrreviation and name.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Operators">
<summary>
 Operators.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Sxsubstitution">
<summary>
 Sx abbreviation. For example, St = std, Sa = std :: allocator.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Name">
<summary>
 Name composed of string.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.TemplateSub">
<summary>
 Template substituion.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Num">
<summary>
 Number.
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Specific">
<summary>
 Used for marking the index of used template substitution
(e.g., T2_ gives 2).
</summary>
</member>
<member name="T:B2R2.NameMangling.ItaniumExpr.Dummy">
<summary>
 Dummy type.
</summary>
</member>
<member name="T:B2R2.NameMangling.RestrictQualifier">
<summary>
 Restrict qualifier including optional const and volatile qualifier.
 It is consisted of quadruple, restrict, optional const and volatile and
 pointer. Nothing implies no qualifier and pointer, JustPointer implies
 only pointer.
</summary>
</member>
<member name="T:B2R2.NameMangling.ConsTandVolatile">
<summary>
 Qualifiers: const, volatile. ConstaVolatile defines const volatile together.
</summary>
</member>
<member name="M:B2R2.NameMangling.MSUtils.changeToNormalPointer(B2R2.NameMangling.MSExpr)">
<summary>
 Changes any type of pointer to normal pointer while keeping its prefixes.
</summary>
</member>
<member name="M:B2R2.NameMangling.MSUtils.updatePrefix(Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ModifierPrefix},System.String)">
<summary>
 Checks for the existance of &amp; and &amp;&amp; indicating prefixes and updates the
 pointer string to include them.
</summary>
</member>
<member name="M:B2R2.NameMangling.MSUtils.getPrefixModStr(Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ModifierPrefix})">
<summary>
 Gets the preModifierString and postModifierString.
 For modifiers that appear before and after the pointer symbol.
</summary>
</member>
<member name="M:B2R2.NameMangling.MSInterpreter.interpret(B2R2.NameMangling.MSExpr)">
<summary>
 Main interpreter function that outputs the demangled string
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.merge(B2R2.NameMangling.ItaniumExpr,Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr},Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr})">
<summary>
 Applying previous function for every element in the list part of
 FunctionBegin.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getQualifierandP(B2R2.NameMangling.ItaniumExpr,Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr},Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr})">
<summary>
 Seperating pointers associated with qualifiers.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getPointers(B2R2.NameMangling.ItaniumExpr,Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr},Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr},System.Int32)">
<summary>
 Seperating pointers in start of beginning of function pointer for
 substitution.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.combine(Microsoft.FSharp.Collections.FSharpList{System.String},System.Int32,System.String)">
<summary>
 Combining arguments list.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getReturnList(System.String)">
<summary>
 Getting return and argument list.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getList(System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Collecting seperated parts from previous function.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getQualifier(System.String,System.Int32)">
<summary>
 Getting qualifiers.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getArgs(System.String,System.Int32,System.Int32,System.String)">
<summary>
 Seperating argument part of each function pointer.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumFunctionPointer.getReturn(System.String,System.Int32,System.Int32,System.String)">
<summary>
 Getting return from string gained from interpreter for FunctionPointer in
 ItaniumInterpreter.fs.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.expandCL``1(B2R2.NameMangling.ItaniumExpr)">
<summary>
 If arguments of expression is list of arguments, meaning pack expansion,
 seperate expressions each with one argument from list is created.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.createTemplates(B2R2.NameMangling.ItaniumExpr,Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr},Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr})">
<summary>
 If argument of template is argument pack it is expanded into seperate
 templates each containing one argument from pack.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addOnCondition(B2R2.NameMangling.ItaniumExpr)">
<summary>
 When there is reference qualifier, pack is added one more as whole.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addArgPack(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Adding arguments pack to substitution list.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addtoList(B2R2.NameMangling.ItaniumExpr,Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr},Microsoft.FSharp.Collections.FSharpList{B2R2.NameMangling.ItaniumExpr})">
<summary>
 Adding every element in the pack to substitution list.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.checkBeginning``1(B2R2.NameMangling.ItaniumExpr,``0)">
<summary>
 If template name is formed from constructor or destructor then return is not
 included.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.newsaveandreturn(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{B2R2.NameMangling.ItaniumUserState},FParsec.Reply{B2R2.NameMangling.ItaniumExpr}})">
<summary>
 Parsing return with respect to flag.
</summary>
</member>
<member name="P:B2R2.NameMangling.ItaniumUtils.flagOn">
<summary>
 Functions for managing RetFlag. This flag is used to determine whether
 mangling includes return value or not.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addTsubtolist(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Template substitution can be substituted by general substitution.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addTemplate(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Adding single template to the substitution list.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.checkcarry(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Creating template substitution list consisted of only template arguments.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.saveandreturn``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{B2R2.NameMangling.ItaniumUserState},FParsec.Reply{``0}})">
<summary>
 Adding arguments of template into list before the whole template itself.
</summary>
</member>
<member name="P:B2R2.NameMangling.ItaniumUtils.clearCarry">
<summary>
 Resetting carry.
</summary>
</member>
<member name="P:B2R2.NameMangling.ItaniumUtils.removelast">
<summary>
 Function names are not included in substitution. In case of nested names
 last added unit is removed.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.updatecarry(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Updating carry when we reach Sx abrreviation. They are not substituted
 individually.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addtoNamelist(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Adding NestedName to substitution list.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addargumenttolist(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Adding arguments to substitution list. Seperating qualifiers and pointers
 for substitution.
</summary>
</member>
<member name="M:B2R2.NameMangling.ItaniumUtils.addfunctionptolist(B2R2.NameMangling.ItaniumExpr)">
<summary>
 Adding Function Pointer to substitution list.
</summary>
</member>
</members>
</doc>
