<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>B2R2.VSA</name></assembly>
<members>
<member name="T:B2R2.VSA.MemRgn">
<summary>
 2.1 Memory Region
 This is also used in ValueSet when fetching StridedIntervals.
</summary>
</member>
<member name="T:B2R2.VSA.Bool3">
<summary>
 4.2.6 Boolean of flag setup and bit arithmetics
 This may be used for comparison.
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Widen(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 7.1. Widening
 TODO : Consider constraint such as Figure 7.1 of
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Sub(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.2.3 Subtraction Increment and Decrement
 F# do not support increment and decrement as they only works for the
 mutable.
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.signedMinOR(B2R2.BitVector,B2R2.BitVector,B2R2.BitVector,B2R2.BitVector,System.Int32)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.signedMaxOR(B2R2.BitVector,B2R2.BitVector,B2R2.BitVector,B2R2.BitVector,System.Int32)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.RemoveUpperBounds(B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 3.1. Value-Set
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.RemoveLowerBounds(B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 3.1. Value-Set
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.op_Addition(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 Below represents abstract interpretation for the infix operators.
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.ntz(B2R2.BitVector)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.2.4. Bitwise Or
 This counts the Number of Trailing Zeros (NTZ)
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Neg(B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.2.2 Unary minus
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Mul(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 https://drona.csa.iisc.ac.in/~srikant/papers-theses/memocode-2007.pdf
 4.2 Arithmetic Operations
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.initSI(B2R2.BitVector,B2R2.BitVector,B2R2.BitVector,System.Int32)">
<summary>
 This is a wrapper for explicit StridedIntervalValue.
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.getRealUpperBound(B2R2.BitVector,B2R2.BitVector,B2R2.BitVector)">
<summary>
 This returns the effective (real) upper bound. This is because the
 upperbound may not be included in a given strided interval.
 ex) 4[0,15] -&gt; 4[0,12]
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Contains(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 https://people.eng.unimelb.edu.au/pstuckey/papers/toplas15.pdf
 3.2. Ordering wrapped intervals
 In addition, we need to check stride using gcd as strided interval can
 have different integers. (e.g., 2[2, 6] is not in 2[1, 7])
 Here, we also check casting si2 to si1
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Complment(B2R2.VSA.StridedInterval)">
<summary>
 https://jorgenavas.github.io/papers/ACM-TOPLAS-wrapped.pdf
 3.1. Wrapped Intervals, Formally
 We use two&apos;s complement.
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Cardinality(B2R2.VSA.StridedInterval)">
<summary>
 https://jorgenavas.github.io/papers/ACM-TOPLAS-wrapped.pdf
 3.1. Wrapped Intervals, Formally
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.BitwiseOr(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.2.4 Bitwise Or
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.BitwiseNot(B2R2.VSA.StridedInterval)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.2.5 Bitwise Not, And, Xor
</summary>
</member>
<member name="M:B2R2.VSA.StridedInterval.Add(B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval)">
<summary>
 Below represents actual implementation based on :
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.2.1 Addition
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Widen(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 Widen operation for ValueSet. Please check StridedInterval.widen for
 details.
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Union(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 Join operation for ValueSet. Please check StridedInterval.union for
 details.
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Sub(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.3.2 Subtraction
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.SetOtherRgnAll(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 This function is only for constants in RelOpType operation.
 TODO: check if we can use widen operation for this
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.RemoveUpperBounds(B2R2.VSA.ValueSet)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 3.1 Value-Set
 TODO: check if we can use widen operation for this
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.RemoveLowerBounds(B2R2.VSA.ValueSet)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 3.1 Value-Set
 TODO: check if we can use widen operation for this
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.op_Addition(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 Below represents abstract interpretation for the infix operators.
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Neg(B2R2.VSA.ValueSet)">
<summary>
 Unary minus of ValueSet
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Intersection(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 Meet operation for ValueSet. Please check StridedInterval.intersection for
 details.
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.CutUpperBounds(B2R2.VSA.ValueSet)">
<summary>
 Narrow upperbound by one (-1). Currently, we only consider integer range.
 This is used for lt gt comparison.
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.CutLowerBounds(B2R2.VSA.ValueSet)">
<summary>
 Narrow lowerbound by one (+1). Currently, we only consider integer range.
 This is used for lt gt comparison.
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.CutBounds(Microsoft.FSharp.Core.FSharpFunc{B2R2.VSA.StridedInterval,Microsoft.FSharp.Core.FSharpFunc{B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval}},B2R2.VSA.ValueSet)">
<summary>
 Below is helper for CutLowerBounds and CutUpperBounds
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Contains(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 https://people.eng.unimelb.edu.au/pstuckey/papers/toplas15.pdf
 3.2. Ordering wrapped intervals
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.bop(Microsoft.FSharp.Core.FSharpFunc{B2R2.VSA.StridedInterval,Microsoft.FSharp.Core.FSharpFunc{B2R2.VSA.StridedInterval,B2R2.VSA.StridedInterval}},B2R2.VSA.ValueSet,B2R2.VSA.ValueSet,B2R2.VSA.ValueSetType,B2R2.VSA.ValueSetType)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.3.3 Bitwise And, Or, Xor
</summary>
</member>
<member name="M:B2R2.VSA.ValueSet.Add(B2R2.VSA.ValueSet,B2R2.VSA.ValueSet)">
<summary>
 https://research.cs.wisc.edu/wpis/papers/balakrishnan_thesis.pdf
 4.3.1 Addition
 We merged Single and Arb (Arb) as their behavior is the same. Constant
 should be transformed to Global ValueSet and added using this method.
</summary>
</member>
<member name="T:B2R2.VSA.ValueSet">
<summary>
 3.2 This may represent Abstract Environment (AbsEnv)
</summary>
</member>
<member name="T:B2R2.VSA.ValueSetType">
<summary>
 4.3 ValueSet Kind
 We do not need single as it can be handled by Arb. This also embeds MemRgn
 such as Global, AR_main, and so on described in 3.2 (AbsEnv).
 TODO: merge Global to Arb
</summary>
</member>
<member name="T:B2R2.VSA.AbsEnvMap">
<summary>
 AbsEnvMap stores AbsEnv of each Stmt by their VertexID in SSACFG
</summary>
</member>
<member name="T:B2R2.VSA.AbsEnv">
<summary>
 The authors implement AbsEnv with AVL tree, and F#&apos;s Map does so.
</summary>
</member>
<member name="T:B2R2.VSA.ALoc">
<summary>
 2.2 Abstract Location (A-Locs)
 ALoc represents its type, offset, and size.
</summary>
</member>
<member name="M:B2R2.VSA.Analysis.evalSSAExpr``1(B2R2.VSA.ALoc,B2R2.BinIR.SSA.Expr,Microsoft.FSharp.Collections.FSharpMap{B2R2.VSA.ALoc,B2R2.VSA.ValueSet},``0)">
<summary>
 this returns (ValueSet * AbsEnv)
</summary>
</member>
</members>
</doc>
